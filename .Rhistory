# Definir a lógica do servidor necessária
server <- function(input, output) {                                  # Recebe os inputs da UI e calcula outputs
terms <- reactive({   if(input$formato=="excel"){                  # Leitura dos dados ficara armazenada no objeto terms
req(input$file1)                                                 # Para limpar mensagem de erro antes de carregar a base
df <- read_excel(input$file1$datapath,sheet = input$plan)        # Leitura de base excel
}else{                                                             # Se o arquivo nao for excel
req(input$file1)                                                 # Leitura dos dados ficara armazenada no objeto terms
df = read.csv(input$file1$datapath,                              # Leitura da base de dados com os inputs obtidos em ui
header = T,                                        # Base precisa ter cabeçalho
sep = input$sep,encoding = "UTF-8")                # separação informada pelo usuario
}
# temp=as.data.frame(df[,-1])                                    # Retirava primeira coluna de nomes
temp=df                                                          # Armazenando a base no objeto temp
acpcor=prcomp(temp, scale = TRUE)                                # Funcao do R que realiza PCA
})
output$plot1 <- renderPlotly({
acpcor=terms()                                                   # Leitura do objeto armazenado em terms
# Funcao para criar o screeplot:
ggscreeplot <- function(pcobj, type = c('pev', 'cev')) {
type <- match.arg(type)
d <- pcobj$sdev^2
yvar <- switch(type,
pev = d / sum(d),
cev = cumsum(d) / sum(d))
yvar.lab <- switch(type,
pev = 'proportion of explained variance',
cev = 'cumulative proportion of explained variance')
df <- data.frame(PC = 1:length(d), yvar = yvar)
ggplot(data = df, aes(x = PC, y = yvar)) +
xlab('principal component number') + ylab(yvar.lab) +
geom_point() + geom_path()
}
g1=ggscreeplot(acpcor)+                                          # Criando o screeplot
theme_bw()+
labs(title="ScreePlot",
ylab="Porcentagem explicada pela variância",
xlab="Dimensões")
p1=plotly::ggplotly(g1)                                          # Transformando em interativo
g2=autoplot(acpcor,                                              # Criando o gráfico de PCA
label = TRUE,
label.size = 1,
loadings = TRUE,
loadings.label = TRUE,
loadings.label.size  = 3)+
theme_bw()+
labs(title="Análise de Componentes Principais",
ylab="Dim 2",
xlab="Dim 1")
p2=plotly::ggplotly(g2)                                          # Transformando em interativo
subplot(p1, p2, nrows = 1)                                       # Funcao para juntar dois graficos plotly
})
plotInput = function(){                                            # Criando objeto que será utilizando abaixo para download
# Declarando novamente funcao screeplot:
ggscreeplot <- function(pcobj, type = c('pev', 'cev')) {
type <- match.arg(type)
d <- pcobj$sdev^2
yvar <- switch(type,
pev = d / sum(d),
cev = cumsum(d) / sum(d))
yvar.lab <- switch(type,
pev = 'proportion of explained variance',
cev = 'cumulative proportion of explained variance')
df <- data.frame(PC = 1:length(d), yvar = yvar)
ggplot(data = df, aes(x = PC, y = yvar)) +
xlab('principal component number') + ylab(yvar.lab) +
geom_point() + geom_path()
}
acpcor=terms()                                                   # Obtendo o objeto retornado em terms
ggscreeplot(acpcor)+                                             # Grafico que sera disponibilizado para download
theme_bw()+
labs(title="ScreePlot",
ylab="Porcentagem explicada pela variância",
xlab="Dimensões")
}
output$downloadPlot <- downloadHandler(                            # Criando o botao de download
filename = 'screeplot.png',
content = function(file) {
device <- function(..., width, height) {
grDevices::png(..., width = width, height = height,
res = 300, units = "in")
}
ggsave(file, plot = plotInput(), device = device)
})
plotInput = function(){                                          # Criando objeto que será utilizando abaixo para download
# Declarando novamente funcao screeplot:
ggscreeplot <- function(pcobj, type = c('pev', 'cev')) {
type <- match.arg(type)
d <- pcobj$sdev^2
yvar <- switch(type,
pev = d / sum(d),
cev = cumsum(d) / sum(d))
yvar.lab <- switch(type,
pev = 'proportion of explained variance',
cev = 'cumulative proportion of explained variance')
df <- data.frame(PC = 1:length(d), yvar = yvar)
ggplot(data = df, aes(x = PC, y = yvar)) +
xlab('principal component number') + ylab(yvar.lab) +
geom_point() + geom_path()
}
acpcor=terms()                                                   # Obtendo o objeto retornado em terms
autoplot(acpcor,                                                 # Grafico que sera disponibilizado para download
label = TRUE,
label.size = 1,
loadings = TRUE,
loadings.label = TRUE,
loadings.label.size  = 3)+
theme_bw()+
labs(title="Análise de Componentes Principais",
ylab="Dim 2",
xlab="Dim 1")
}
output$downloadPlot2 <- downloadHandler(                           # Criando o segundo botao de download
filename = 'acp.png',
content = function(file) {
device <- function(..., width, height) {
grDevices::png(..., width = width, height = height,
res = 300, units = "in")
}
ggsave(file, plot = plotInput(), device = device)
})
######################################
# Abaixo os outputs da funcao prcomp #
######################################
output$sdev <- DT::renderDataTable({
acpcor=terms()
DT::datatable(as.data.frame(round(acpcor$sdev,4)),
options = list(pageLength = 25))
})
output$rotation <- DT::renderDataTable({
acpcor=terms()
DT::datatable(as.data.frame(round(acpcor$rotation,4)),
options = list(pageLength = 25))
})
output$center <- DT::renderDataTable({
acpcor=terms()
DT::datatable(as.data.frame(round(acpcor$center,4)),
options = list(pageLength = 25))
})
output$scale <- DT::renderDataTable({
acpcor=terms()
DT::datatable(as.data.frame(round(acpcor$scale,4)),
options = list(pageLength = 25))
})
output$x <- DT::renderDataTable({
acpcor=terms()
DT::datatable(as.data.frame(round(acpcor$x,4)),
options = list(pageLength = 25))
})
output$summary <- renderPrint({
acpcor=terms()
summary(acpcor)
})
#######################################
# Encerra os outputs da funcao prcomp #
#######################################
output$plot3 <- renderPlotly({
acpcor=terms()                                                   # Leitura do objeto armazenado em terms
if(input$formato=="excel"){                                      # Leitura dos dados ficara armazenada no objeto terms
req(input$file1)                                               # Para limpar mensagem de erro antes de carregar a base
df <- read_excel(input$file1$datapath,sheet = input$plan)      # Leitura de base excel
}else{                                                           # Se o arquivo nao for excel
req(input$file1)                                               # Leitura dos dados ficara armazenada no objeto terms
df = read.csv(input$file1$datapath,                            # Leitura da base de dados com os inputs obtidos em ui
header = T,                                      # Base precisa ter cabeçalho
sep = input$sep,encoding = "UTF-8")              # separação informada pelo usuario
}
plot_kmeans = function(df, cluster=input$cluster) {              # Funcao para plotar o agrupamento k means
#cluster
tmp_k = kmeans(df, centers = cluster, nstart = 100)
#factor
tmp_f = acpcor
#collect data
tmp_d = data.frame(matrix(ncol=0, nrow=nrow(df)))
tmp_d$cluster = as.factor(tmp_k$cluster)
tmp_d$fact_1 = as.numeric(tmp_f$x[, 1])
tmp_d$fact_2 = as.numeric(tmp_f$x[, 2])
tmp_d$label = rownames(df)
#plot
g = ggplot(tmp_d, aes(fact_1, fact_2, color = cluster)) +
geom_point() +
geom_text(aes(label = label),
size = 3,
vjust = 1,
color = "black")
return(g)
}
g1=plot_kmeans(df)+
theme_bw()+
labs(title="Agrupamento com k-means",
ylab="Dim 2",
xlab="Dim 1")
ggplotly(g1)
})
plotInput = function(){
acpcor=terms()                                                   # Leitura do objeto armazenado em terms
if(input$formato=="excel"){                                      # Leitura dos dados ficara armazenada no objeto terms
req(input$file1)                                               # Para limpar mensagem de erro antes de carregar a base
df <- read_excel(input$file1$datapath,sheet = input$plan)      # Leitura de base excel
}else{                                                           # Se o arquivo nao for excel
req(input$file1)                                               # Leitura dos dados ficara armazenada no objeto terms
df = read.csv(input$file1$datapath,                            # Leitura da base de dados com os inputs obtidos em ui
header = T,                                      # Base precisa ter cabeçalho
sep = input$sep,encoding = "UTF-8")              # separação informada pelo usuario
}
plot_kmeans = function(df, cluster=input$cluster) {              # Funcao para plotar o agrupamento k means
#cluster
tmp_k = kmeans(df, centers = cluster, nstart = 100)
#factor
tmp_f = acpcor
#collect data
tmp_d = data.frame(matrix(ncol=0, nrow=nrow(df)))
tmp_d$cluster = as.factor(tmp_k$cluster)
tmp_d$fact_1 = as.numeric(tmp_f$x[, 1])
tmp_d$fact_2 = as.numeric(tmp_f$x[, 2])
tmp_d$label = rownames(df)
#plot
g = ggplot(tmp_d, aes(fact_1, fact_2, color = cluster)) +
geom_point() +
geom_text(aes(label = label),
size = 3,
vjust = 1,
color = "black")
return(g)
}
plot_kmeans(df)+
theme_bw()+
labs(title="Agrupamento com k-means",
ylab="Dim 2",
xlab="Dim 1")
}
output$downloadPlot3 <- downloadHandler(                            # Criando o botao de download
filename = 'kmeans.png',
content = function(file) {
device <- function(..., width, height) {
grDevices::png(..., width = width, height = height,
res = 300, units = "in")
}
ggsave(file, plot = plotInput(), device = device)
})
output$plot4 <- renderScatterplotThree({
acpcor=terms()
if(input$formato=="excel"){                                      # Leitura dos dados ficara armazenada no objeto terms
req(input$file1)                                               # Para limpar mensagem de erro antes de carregar a base
df <- read_excel(input$file1$datapath,sheet = input$plan)      # Leitura de base excel
}else{                                                           # Se o arquivo nao for excel
req(input$file1)                                               # Leitura dos dados ficara armazenada no objeto terms
df = read.csv(input$file1$datapath,                            # Leitura da base de dados com os inputs obtidos em ui
header = T,                                      # Base precisa ter cabeçalho
sep = input$sep,encoding = "UTF-8")              # separação informada pelo usuario
}
plot_kmeans = function(df, cluster=input$cluster) {              # Funcao para plotar o agrupamento k means
#cluster
tmp_k = kmeans(df, centers = cluster, nstart = 100)
#factor
tmp_f = acpcor
#collect data
tmp_d = data.frame(matrix(ncol=0, nrow=nrow(df)))
tmp_d$cluster = as.factor(tmp_k$cluster)
tmp_d$fact_1 = as.numeric(tmp_f$x[, 1])
tmp_d$fact_2 = as.numeric(tmp_f$x[, 2])
tmp_d$label = rownames(df)
#plot
g = ggplot(tmp_d, aes(fact_1, fact_2, color = cluster)) +
geom_point() +
geom_text(aes(label = label),
size = 3,
vjust = 1,
color = "black")
return(g)
}
g=plot_kmeans(df)+
theme_bw()+
labs(title="Agrupamento com k-means",
ylab="Dim 2",
xlab="Dim 1")
scatterplot3js(as.matrix(data.frame(pc1=as.vector(acpcor$x[,1]),pc2=as.vector(acpcor$x[,2]),pc3=as.vector(acpcor$x[,3]))),color = as.numeric(g$data$cluster),size = 0.5, flip.y=TRUE)
})
output$valida1 <- renderPrint({
if(input$formato=="excel"){                                      # Leitura dos dados ficara armazenada no objeto terms
req(input$file1)                                               # Para limpar mensagem de erro antes de carregar a base
df <- read_excel(input$file1$datapath,sheet = input$plan)      # Leitura de base excel
}else{                                                           # Se o arquivo nao for excel
req(input$file1)                                               # Leitura dos dados ficara armazenada no objeto terms
df = read.csv(input$file1$datapath,                            # Leitura da base de dados com os inputs obtidos em ui
header = T,                                      # Base precisa ter cabeçalho
sep = input$sep,encoding = "UTF-8")              # separação informada pelo usuario
}
#Medidas de validação:
valida1=clValid(df,input$cluster,clMethods=c("kmeans"),validation="internal")
summary(valida1)
})
output$valida2 <- renderPrint({
if(input$formato=="excel"){                                      # Leitura dos dados ficara armazenada no objeto terms
req(input$file1)                                               # Para limpar mensagem de erro antes de carregar a base
df <- read_excel(input$file1$datapath,sheet = input$plan)      # Leitura de base excel
}else{                                                           # Se o arquivo nao for excel
req(input$file1)                                               # Leitura dos dados ficara armazenada no objeto terms
df = read.csv(input$file1$datapath,                            # Leitura da base de dados com os inputs obtidos em ui
header = T,                                      # Base precisa ter cabeçalho
sep = input$sep,encoding = "UTF-8")              # separação informada pelo usuario
}
valida2=clValid(df,input$cluster,clMethods=c("kmeans"),validation="stability")
summary(valida2)
})
}
# Executa o aplicativo
shinyApp(ui = ui, server = server)
library(quantmod)
library(data.table)
library(knitr)
allStocks <- data.table(stockSymbols())
kable(allStocks)
View(allStocks)
table(allStocks$Exchange)
shiny::runGitHub("shiny-js-examples", "jcheng5", subdir="input")
runApp('fb-login', port = 5000)
library(shiny)
# Call this function with all the regular navbarPage() parameters, plus a text parameter,
# if you want to add text to the navbar
navbarPageWithText <- function(..., text) {
navbar <- navbarPage(...)
textEl <- tags$p(class = "navbar-text", text)
navbar[[3]][[1]]$children[[1]] <- htmltools::tagAppendChild(
navbar[[3]][[1]]$children[[1]], textEl)
navbar
}
# Call this function with an input (such as `textInput("text", NULL, "Search")`) if you
# want to add an input to the navbar
navbarPageWithInputs <- function(..., inputs) {
navbar <- navbarPage(...)
form <- tags$form(class = "navbar-form", inputs)
navbar[[3]][[1]]$children[[1]] <- htmltools::tagAppendChild(
navbar[[3]][[1]]$children[[1]], form)
navbar
}
# When creating the UI, call our wrapper function instead of `navbarPage()`
ui <- navbarPageWithText(
"Test app",
tabPanel("tab1", "tab 1"),
tabPanel("tab2", "tab 2"),
text = "User: Dean"
)
server <- function(input, output, session) {
}
shinyApp(ui = ui, server = server)
# NOT RUN {
if (interactive()) {
ui <- fluidPage(
tags$h1("Search Input"),
br(),
searchInput(
inputId = "search", label = "Enter your text",
placeholder = "A placeholder",
btnSearch = icon("search"),
btnReset = icon("remove"),
width = "450px"
),
br(),
verbatimTextOutput(outputId = "res")
)
server <- function(input, output, session) {
output$res <- renderPrint({
input$search
})
}
shinyApp(ui = ui, server = server)
}
# }
ui <- fluidPage(
tags$h1("Search Input"),
br(),
searchInput(
inputId = "search", label = "Enter your text",
placeholder = "A placeholder",
btnSearch = icon("search"),
btnReset = icon("remove"),
width = "450px"
),
br(),
verbatimTextOutput(outputId = "res")
)
server <- function(input, output, session) {
output$res <- renderPrint({
input$search
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage(
tags$h1("Search Input"),
br(),
searchInput(
inputId = "search", label = "Enter your text",
placeholder = "A placeholder",
btnSearch = icon("search"),
btnReset = icon("remove"),
width = "450px"
),
br(),
verbatimTextOutput(outputId = "res")
)
server <- function(input, output, session) {
output$res <- renderPrint({
input$search
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage(
tags$h1("Search Input"),
br(),
searchInput(
inputId = "search", label = "Enter your text",
placeholder = "A placeholder",
btnSearch = icon("search"),
btnReset = icon("remove"),
width = "450px"
),
br(),
verbatimTextOutput(outputId = "res")
)
server <- function(input, output, session) {
output$res <- renderPrint({
input$search
})
}
shinyApp(ui = ui, server = server)
ui <- fluidPage(
tags$h1("Search Input"),
br(),
searchInput(
inputId = "search", label = "Enter your text",
placeholder = "A placeholder",
btnSearch = icon("search"),
btnReset = icon("remove"),
width = "450px"
),
br(),
verbatimTextOutput(outputId = "res")
)
server <- function(input, output, session) {
output$res <- renderPrint({
input$search
})
}
shinyApp(ui = ui, server = server)
library(shinyWidgets)
ui <- fluidPage(
tags$h1("Search Input"),
br(),
searchInput(
inputId = "search", label = "Enter your text",
placeholder = "A placeholder",
btnSearch = icon("search"),
btnReset = icon("remove"),
width = "450px"
),
br(),
verbatimTextOutput(outputId = "res")
)
server <- function(input, output, session) {
output$res <- renderPrint({
input$search
})
}
shinyApp(ui = ui, server = server)
rm(allStocks)
View(SPY)
plot(SPY)
autoplot(SPY)
library(ggplot2)
autoplot(SPY)
body <- dashboardBody(
fluidRow(
tabBox(
title = "First tabBox",
# The id lets us use input$tabset1 on the server to find the current tab
id = "tabset1", height = "250px",
tabPanel("Tab1", "First tab content"),
tabPanel("Tab2", "Tab content 2")
),
tabBox(
side = "right", height = "250px",
selected = "Tab3",
tabPanel("Tab1", "Tab content 1"),
tabPanel("Tab2", "Tab content 2"),
tabPanel("Tab3", "Note that when side=right, the tab order is reversed.")
)
),
fluidRow(
tabBox(
# Title can include an icon
title = tagList(shiny::icon("gear"), "tabBox status"),
tabPanel("Tab1",
"Currently selected tab from first box:",
verbatimTextOutput("tabset1Selected")
),
tabPanel("Tab2", "Tab content 2")
)
)
)
shinyApp(
ui = dashboardPage(
dashboardHeader(title = "tabBoxes"),
dashboardSidebar(),
body
),
server = function(input, output) {
# The currently selected tab from the first box
output$tabset1Selected <- renderText({
input$tabset1
})
}
)
